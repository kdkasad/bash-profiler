#!/usr/bin/env bash

#
# Profiles execution of shell scripts
#
# Copyright (C) 2025  Kian Kasad <kian@kasad.com>
#
# You are free to use, modify, and redistribute this script subject to the
# following conditions:
#   1. You preserve the above copyright notice.
#   2. You make any modifications or derivative works publicly available and free
#      of charge.
#   3. This script may not be used as the basis for any CS 252 assignments
#      without express written permission from the author.
#

set -e -u -o pipefail

# Check Bash version
if [ -z "$BASH_VERSION" ]
then
    echo 'Cannot detect Bash version. Are you running this with Bash?' >&2
    exit 1
fi
if [ "${BASH_VERSINFO[0]}" -lt 4 ] || [ "${BASH_VERSINFO[0]}" -eq 4 ] && [ "${BASH_VERSINFO[1]}" -lt 1 ]
then
    echo 'Bash version 4.1 or greater is required for this script.' >&2
    echo "You appear to be running version $BASH_VERSION." >&2
    exit 1
fi

# Save script name
argv0="$0"

# Print top-level usage information
usage() {
    cat << EOF
Usage:
    $argv0 [-h]
    $argv0 profile [-h] [-f DATA_FILE] [--] <SCRIPT> [ARGS...]
    $argv0 analyze [-h] [-p] [DATA_FILE]

Subcommands:
    profile    Measure the execution of the given script.
    analyze    Analyze the raw data generated by the \`profile' subcommand.
EOF
}

# Print `profile' subcommand's usage information
usage_profile() {
    cat << EOF
Usage:
    $argv0 profile [-h] [-f DATA_FILE] [--] <SCRIPT> [ARGS...]

Description:
    Profiles the Bash script given by SCRIPT. If ARGS are provided, they are
    passed to the script.

Options:
    -h              Show this usage information.
    -f DATA_FILE    Output data to DATA_FILE. Defaults to \`profiler.log'.
EOF
}

# Print `analyze' subcommand's usage information
usage_analyze() {
    cat << EOF
Usage:
    $argv0 analyze [-h] [-p] [-g GROUP_MODE] [DATA_FILE]

Description:
    Analyzes the raw profile data produced by \`$argv0 profile'.
    Reads data from DATA_FILE, which defaults to \`profiler.log' if not set.

    Produces an output which looks similar to the raw data, but consists of
    lines in the following format.

    DURATION NEST COMMAND

    The columns are separated by spaces. DURATION is the time taken by the
    command in seconds, with microsecond precision. NEST is a sequence of
    repeated \`+' characters, indicating the level of nesting. This is the same
    as the nesting indicator printed by \`set -x'. COMMAND is the command run.

Options:
    -h              Show this usage information.
    -s              Sort the output by duration.
    -g GROUP_MODE   Aggregate durations of separate commands. See the
                    "Grouping" section below.

Grouping:
    By default, the analysis outputs the duration for each individual command.
    This means that if the body of a loop runs 10 times, each command in the
    body will be printed 10 times, with the duration each invocation took.

    Grouping modes can be used to group the output into more useful bins. The
    available modes are:
        cmd    Group all commands with the same command line. Output will only
               include the duration and command columns.
        line   Group commands based on source file & line number. This option
               is particularly useful for scripts with loops. Output will only
               include the duration, source file, and line number columns.

    Note that grouping can slow down analysis significantly.
EOF
}

# Profiler implementation
profile() {
    # Set default options
    local file=profiler.log

    # Parse arguments
    while getopts ":hf:" opt
    do
        case "$opt" in
            \?) echo "Unrecognized option: \`-$OPTARG'" >&2; exit 2 ;;
            :) echo "Missing argument for option \`-$OPTARG'" >&2; exit 2 ;;
            h) usage_profile; exit 0 ;;
            f) file="$OPTARG" ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    # Workaround for weird behavior on Purdue systems
    if [ "${BASH_ENV:-}" = '/usr/share/lmod/lmod/init/bash' ]
    then
        unset BASH_ENV
    fi

    # Open a file descriptor for writing to $file and save it in $tracefd
    exec {tracefd}>"$file"
    # Send trace output to $tracefd
    export BASH_XTRACEFD="$tracefd"
    # Print microsecond time in trace output
    export PS4='+\011$EPOCHREALTIME\011${BASH_SOURCE[0]}\011$LINENO\011${FUNCNAME[0]:--}\011'
    # Enable tracing, run script, and disable tracing
    set -x
    bash -x -- "$@"
    set +x
    # Un-redirect the trace output. This also closes the file descriptor.
    unset BASH_XTRACEFD
    export -n BASH_XTRACEFD PS4

    # Remove "source" line from output and change last line to only include the
    # nest level and timestamp.
    sed -i -e 1d -e '$s/^\(+\+\t[0-9\.]\+\)\t.*$/\1/' "$file"
}

analyze() {
    # Set defaults
    local file=profiler.log groupmode=
    local -a sortcmd=(cat) tablecmd=(cat)

    # Parse options
    while getopts ":hsg:" opt
    do
        case "$opt" in
            \?) echo "Unrecognized option: \`-$OPTARG'" >&2; exit 2 ;;
            :) echo "Missing argument for option \`-$OPTARG'" >&2; exit 2 ;;
            h) usage_analyze; exit 0 ;;
            s) sortcmd=(sort -n) ;;
            g)
                case "$OPTARG" in
                    cmd|line) groupmode="$OPTARG" ;;
                    *) echo "Invalid grouping mode \`$OPTARG'." >&2; exit 2 ;;
                esac
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    # Get file argument
    if [ $# -ge 1 ]
    then
        file="$1"
    fi

    # Function to calculate duration of each command
    calc_durations() {
        local file="$1"
        # Declare variables
        local line nextline duration
        # Open file as a file descriptor so we can re-use the same stream
        exec {fd}<"$file";
        # Read first line
        IFS=$'\t' read -r -a line <&"$fd"
        # Process each line
        while IFS=$'\t' read -r -a nextline
        do
            # Line is nestlvl timestamp file line function cmd
            duration="$(bc <<< "scale=6; ${nextline[1]} - ${line[1]}")"
            # Prepend leading zero
            if [ "${duration:0:1}" = . ]
            then
                duration="0$duration"
            fi
            printf '%s\t%s\t%s\t%s\t%s\t%s\n' \
                "$duration" "${line[0]}" "${line[2]}" "${line[3]}" "${line[4]}" "${line[5]}"
            #   duration    nestlvl      file         line         function     cmd

            line=("${nextline[@]}")
        done <&"$fd"
        # Close file descriptor
        exec {fd}<&-
    }

    # Function to perform grouping
    do_groupings() {
        local mode="$1"

        # Map used for grouping
        local -A groupmap

        local duration _nestlvl file line _function cmd
        while IFS=$'\t' read -r duration _nestlvl file line _function cmd
        do
            local key
            case "$mode" in
                cmd) key="$cmd" ;;
                line) key="$file"$'\t'"$line" ;;
            esac
            if [ -z "${groupmap["$key"]:-}" ]
            then
                groupmap["$key"]="$duration"
            else
                groupmap["$key"]="$(bc <<< "scale=6; $duration + ${groupmap["$key"]}")"
            fi
        done

        # Print final map
        for key in "${!groupmap[@]}"
        do
            local duration="${groupmap["$key"]}"
            # Prepend leading zero
            if [ "${duration:0:1}" = . ]
            then
                duration="0$duration"
            fi
            printf '%s\t%s\n' "$duration" "$key"
        done
    }

    if [ -n "$groupmode" ]
    then
        calc_durations "$file" | do_groupings "$groupmode"
    else
        calc_durations "$file"
    fi | "${sortcmd[@]}" | "${tablecmd[@]}"
}

# Parse arguments
if [ $# -lt 1 ]
then
    usage >&2
    exit 2
fi
subcommand="$1"
shift
case "$subcommand" in
    -h)
        usage
        exit 0
        ;;
    profile | analyze)
        "$subcommand" "$@"
        ;;
    *)
        echo "Unrecognized subcommand: \`$subcommand'" >&2
        exit 2
        ;;
esac
